--[[
Author: Antglobes
Last Modified: 28/01/25
Purpose: Main Tracking & Map Spot Functionality
]]

-- Imports

faction_to_colour = wetd_utils.faction_to_colour
faction_to_name = wetd_utils.faction_to_name
special_character_faction = wetd_utils.special_character_faction
get_mutant_name = wetd_utils.get_mutant_name
get_colour_string = wetd_utils.get_colour_string
get_condition_colour = wetd_utils.get_condition_colour
capitalise = wetd_utils.capitalise
contains = wetd_utils.contains
gts = wetd_utils.get_translation
get_closest_smart = wetd_utils.get_closest_smart
get_smart_name = wetd_utils.get_smart_name
get_unknown_object = wetd_utils.get_unknown_object
dist_to_pos = wetd_utils.dist_to_pos
get_scripts_installed = wetd_utils.get_scripts_installed
attitude_to_clr = wetd_utils.attitude_to_clr
is_enemy = wetd_utils.is_enemy
is_friend = wetd_utils.is_friend
is_story_npc = wetd_utils.is_story_npc
get_real_community = wetd_utils.get_real_community
get_ammo_type = wetd_utils.get_ammo_type

-- Constants

MAX_TRACKING_DIST = 30
LAST_KNOWN_SPOT_ICON = "red_location"
TRACKING_SPOT_TEXT = "ui_st_pda_tracking"
LAST_KNOWN_SPOT_TEXT = "ui_st_pda_last_known"
IGI_DART_GUN = "wpn_igi_ks23_ecolog"
IGI_DART_AMMO = "ammo_23_igi_eco"
EXPECTED_SCRIPTS = {"igi_utils"}
MAP_SPOT_TIMEOUT = 300000 --- 5 MINTUES
MAP_SPOT_ICON_PREFIX = "unknown_"
TRACKER_AMMO_NORMAL  = "ammo_23_wetd_tracker_normal"
TRACKER_AMMO_VET = "ammo_23_wetd_tracker_vet"
TRACKER_AMMO_SIG = "ammo_23_wetd_tracker_sig"
ACCEPTED_AMMO_TYPES = parse_list(ini_sys, IGI_DART_GUN, "ammo_class")



-- Globals (script)
local tracking_npc = {}
local aggro_npcs = {}
local yellow_clr = utils_xml.get_color("yellow")
local gray_1_clr = utils_xml.get_color("ui_gray_1")
local pda_white_clr = utils_xml.get_color("pda_white")
local red_clr = utils_xml.get_color("d_red")


-- Debug

function pr(str, ...)
    wetd_utils.dbg_pr("WETD | Main: %s", str, ...)
end

-- Known Stalkers



-- Helpers

function get_npc_name(npc)
    return IsStalker(npc) and npc:character_name() or get_mutant_name(npc:section())
end

function is_mutant(npc)
    return get_real_community(npc) == "monster"
end


function get_connection_stren(stren)
    stren = round(stren * 100)
    if stren <= 25 then
        return "Strong"
    elseif stren <= 45 then
        return "Average"
    elseif stren <= 65 then
        return "Ok"
    elseif stren <= 85 then
        return "Weak"
    else
        return "Searching ..."
    end

end

function get_hint(npc, hint_keys)
    local hint = yellow_clr ..  gts(TRACKING_SPOT_TEXT) .. "\\n"
    local knows_stalker = is_known_stalker(npc:id())
    local name = get_npc_name(npc)
    
    if not knows_stalker then
        name = "Unknown"
    end

    if contains(hint_keys, "name") then
        hint = hint .. gray_1_clr .. "Name: " .. pda_white_clr .. name .. "\\n"

    elseif contains(hint_keys, "faction") then
        local faction = get_real_community(npc)

        if not knows_stalker then
            faction = "unknown"
        end

        if not contains(faction_to_name, faction, true) then
            faction = special_character_faction[name]
        end
        hint = hint .. gray_1_clr .. "Faction: " .. strformat("%c[255, %s, %s, %s]", unpack(faction_to_colour[faction])) .. faction_to_name[faction] .. "\\n"

    elseif contains(hint_keys, "health") then
        local npc_health = npc.health > 0 and npc.health or 0
        hint = hint .. gray_1_clr .. "Health: " .. get_condition_colour(npc.health) .. strformat("%s", round(npc_health * 100)) .. "%\\n"

    elseif contains(hint_keys, "distance") then
        local dist = distance_between(npc, db.actor)

        if knows_stalker then
            hint = hint .. gray_1_clr .. "Distance: " .. get_condition_colour(dist / MAX_TRACKING_DIST, true) .. round_idp(dist, 2) .. "m \\n"
        else
            hint = hint .. gray_1_clr .. "Connection: " .. get_condition_colour(dist / MAX_TRACKING_DIST, true) .. get_connection_stren(dist / MAX_TRACKING_DIST) .. "\\n"
        end

    elseif contains(hint_keys, "attitude") then
        local attitude = get_npc_attitude(npc)
        hint = hint .. gray_1_clr .. "Attitude: " .. get_attitude_clr(attitude) .. capitalise(attitude) .. "\n"    
    end

    return hint
end

function get_last_known_hint(npc)
    local hint = get_hint(npc, {"name", "faction"})
    local smart_name = gts(get_closest_smart(npc:position()):name())
    local last_known_hint = hint .. gray_1_clr .. "Last Known Location:\\n" .. red_clr .. get_smart_name(get_closest_smart(npc)) .. "\\n"
    return last_known_hint
end

function get_tracking_info(npc) -- ui enemy health
    local dist = distance_between(npc, db.actor)
    local ammo_type = get_tracker_ammo(npc:id())
    local hint = ""

    if ammo_type == TRACKER_AMMO_NORMAL then
        hint = get_hint(npc, {"name", "faction", "distance"})
    elseif ammo_type == TRACKER_AMMO_VET then
        hint = get_hint(npc, {"name", "faction", "health", "distance", "attitude"})
    end

    return  {hint=hint, last_known_hint=get_last_known_hint(npc), dist=dist} 
end

function get_attitude_clr(attitude)
    if not attitude or attitude and attitude == "passive" then attitude = "friend" end
    if attitude == "aggressive" then
        attitude = "enemy"
    end
    return strformat("%c[255, %s, %s, %s]", unpack(attitude_to_clr[attitude]))
end

function get_npc_attitude(npc)
    local attitude = ""
    if is_mutant(npc) then
        attitude = is_aggro_npc(npc:id()) and "aggressive" or "passive"
    elseif IsStalker(npc) then
        if is_story_npc(npc) then 
            attitude = "story"
        elseif is_aggro_npc(npc:id()) or is_enemy(npc) then
            attitude = "enemy"        
        elseif is_friend(npc) then
            attitude = "friend"
        else
            attitude = "neutral"
        end
    end
    return attitude
end

function get_map_spot_icon(npc) --TODO Alter based on upgrades 
    local spot_icon = MAP_SPOT_ICON_PREFIX
    local attitude = get_npc_attitude(npc)
    if is_mutant(npc) then
        spot_icon = spot_icon .. "mutant_" .. attitude 
    else
        spot_icon = spot_icon .. "stalker_" .. attitude
    end
    return spot_icon
end

function get_tracker_ammo(id)
    return contains(tracking_npc[id], "ammo_type", true) and tracking_npc[id]["ammo_type"]
end

-- Tracking Map Spots

function has_map_spot(id, icon)
    return level.map_has_object_spot(id, icon) ~= 0 and contains(tracking_npc[id]["spots"], icon) or false
end

function has_last_known_spot(id)
    return contains(tracking_npc[id], "last_known_spot", true) and has_map_spot(id, LAST_KNOWN_SPOT_ICON)
end

function add_map_spot(id, icon, text, hint)
    if not has_map_spot(id, icon) then
        pr("adding map spot: %s", icon)
        level.map_add_object_spot_ser(id, icon, text)

        if contains(tracking_npc[id], "spots", true) and not contains(tracking_npc[id]["spots"], icon) then
            tracking_npc[id]["spots"][#tracking_npc[id]["spots"] + 1] = icon
            pr("%s added to spot list", icon)
        end
    
        if hint then
            pr("adding map spot hint for: %s", id)
            add_map_spot_hint(id, icon, hint)
        end
    end
end

function add_map_spot_hint(id, icon, hint)
    level.map_change_spot_hint(id, icon, hint)
end

function remove_map_spot(id, icon)
    if not has_map_spot(id, icon) then return end
    pr("removing map spot %s for: %s", icon, id)
    level.map_remove_object_spot(id, icon)
    level.map_remove_object_spot(id, icon)
end

function remove_tracking_spot(id, icon, full)
    remove_map_spot(id, icon)
    if full then
        stop_tracking(id)
    end
end

function remove_last_known_spot(id, icon, full)
    remove_map_spot(id, icon)
    local se_obj = alife_object(id)
    if se_obj then
        alife_release(se_obj) 
    end
    if full then
        stop_tracking(id)
    end
end

function remove_all_spots(id, full)
    if is_empty(tracking_npc[id]["spots"]) then return end
    for idx, icon in pairs(tracking_npc[id]["spots"]) do
        if icon ~= LAST_KNOWN_SPOT_ICON then
            remove_tracking_spot(id, icon, full)
        else
            local lk_info = tracking_npc[id]["last_known_spot"]
            remove_last_known_spot(lk_info["id"], lk_info["spot"], full)
            tracking_npc[id]["lost_contact"] = false
            tracking_npc[id]["last_known_spot"] = nil
        end
    end
end

function update_map_spot(id, icon, text)
    for idx, old_icon in pairs(tracking_npc[id]["spots"]) do
        if icon ~= old_icon and has_map_spot(id, old_icon) then
            pr("updating map spot, removing: %s", old_icon)
            remove_map_spot(id, old_icon)
        end
    end

    add_map_spot(id, icon, text)
end

function init_tracking_spot(npc, ammo_type)
    local id = npc:id()
    local spot_icon = get_map_spot_icon(npc)
    tracking_npc[id] = {
        lost_contact=false,
        timeout=time_global() + MAP_SPOT_TIMEOUT,
        spots={[1]=spot_icon},
        ammo_type=ammo_type,
    
    }
    add_map_spot(id, spot_icon, TRACKING_SPOT_TEXT)
end

function init_last_known_spot(npc, entry, tracking_info) --TODO Get last known info, get tracking info
    local id = npc:id()
    local npc_pos = npc:position()
    local spawn_loc = {
        pos = vector():set(npc_pos.x, -0.005, npc_pos.z),
        lvl_id = npc:level_vertex_id(),
        game_id = npc:game_vertex_id()
    }
    --pr(utils_data.vector_to_string(spawn_loc.pos), spawn_loc.lvl_id, spawn_loc.game_id)
    
    pr("init lk map spot")
    local lks_id = 0
    local lks_icon = LAST_KNOWN_SPOT_ICON
    local lks_pos = spawn_loc["pos"]
    if entry["last_known_spot"] then
        lks_id = entry["last_known_spot"]["id"]
        lks_icon = entry["last_known_spot"]["icon"]
        lks_pos = entry["last_known_spot"]["pos"]
        pr("existing lk info")
    else
        pr("new lk info")
        local obj = alife():create("script_zone", spawn_loc.pos, spawn_loc.lvl_id, spawn_loc.game_id)
        lks_id = obj.id
    end

    --CreateTimeEvent("test_funcs_tracking", "delay_temp_obj_spawn", 0, function()
        local smart_name = get_smart_name(get_closest_smart(npc_pos))                        
        
        if not has_map_spot(lks_id, lks_icon) then
            tracking_npc[id].last_known_spot = {id=lks_id, icon=lks_icon, pos=lks_pos}
           add_map_spot(lks_id, lks_icon, gts(LAST_KNOWN_SPOT_TEXT, smart_name), tracking_info["last_known_hint"])
            pr("changing spot to last known for: %s", lks_id)
        else
            print("temp obj not created")
        end                            
        --return true
   -- end)
end

function forget_tracking_spot(victim, killer, icon)
    local is_monster = is_mutant(victim)
    if not IsStalker(victim) and not is_monster then pr("npc not stalker or monster") return end
    pr("Forgetting Tracking spot")
    local spot_icon = icon and icon or get_map_spot_icon(victim)
    remove_tracking_spot(victim:id(), icon)
    tracking_npc[victim:id()]["lost_contact"] = false
end

function forget_last_known_spot(id, lk_info, length)
    pr("Forgetting last known spot: %s", length)
    remove_last_known_spot(lk_info["id"], lk_info["spot"])
    if length == "temp" then -- out of range + reuse last known spot
        pr("%s is out of range, reusing lk info")
        tracking_npc[id]["lost_contact"] = false    
    elseif length == "perm" then -- within range + new last known spot
        pr("%s is within range, using new lk info")
        tracking_npc[id]["last_known_spot"] = nil
    end
end

-- Tracking Core

function stop_tracking(id)
    if not is_tracking(id) then return end
    pr("stop tracking: %s", id)
    tracking_npc[id] = nil
end

function is_tracking(id)
    return contains(tracking_npc, id, true)
end

function start_tracking(npc, amount, dir, who, bone_index)
    
    if who:id() ~= AC_ID then return end -- pr("not hit by player")
    local is_monster = is_mutant(npc)
    if not IsStalker(npc) and not is_monster then return end -- pr("npc not stalker or monster")
    if contains(tracking_npc, who:id(), true) then return end
    if distance_between(npc, db.actor) > MAX_TRACKING_DIST then return end

    local wpn = db.actor:active_item()
    if wpn and string.find(wpn:section(), IGI_DART_GUN) then

        local ammo_type = get_ammo_type(wpn)
        if contains(ACCEPTED_AMMO_TYPES, ammo_type) then
            pr("starting to  track: %s", get_npc_name(npc))
            init_tracking_spot(npc, ammo_type)
        end
    end
end

function stop_tracking_on_loot()
    CreateTimeEvent("wetd_tracking", "remove_last_known_spot", 0, function()
        local inventory = ui_inventory.GUI
        if not inventory then return true end

        local npc = inventory:GetPartner()
        local npc_id = npc and npc:id()
        if not npc_id or inventory.mode ~= "loot" then return true end
        if not is_tracking(npc_id) then return end

        pr("stopping tracking for %s on loot", get_npc_name(npc))
        remove_all_spots(npc_id, true)

        -- create tracking ammo
        local ammo_type = get_tracker_ammo(npc:id())
        alife():create(ammo_type, npc:position(), npc:level_vertex_id(), npc:game_vertex_id())
    end)
    
end

function on_monster_loot(npc)
    local npc_id =  npc:id()
    if not is_tracking(npc_id) then return end
    pr("stopping tracking for %s on loot", get_npc_name(npc))
    remove_all_spots(npc_id, true)
    local ammo_type = get_tracker_ammo(npc:id())
    alife():create(ammo_type, npc:position(), npc:level_vertex_id(), npc:game_vertex_id())
end

function update_tracking()
    for id, entry in pairs(tracking_npc) do
        local tg = time_global()
        local npc = get_unknown_object({id=id}, "game")

        if npc then
            local spot_icon = get_map_spot_icon(npc)
            local tracking_info = get_tracking_info(npc)
            local dist_to_target = tracking_info["dist"]
            local npc_name = get_npc_name(npc)

            if contains(entry, "timeout", true) and tg >= entry["timeout"] then
                pr("tracking timeout for %s at %s", npc_name, entry["timeout"])
                remove_all_spots(id, true)
                return
            end

            -- as long as target is on the same level track them
            if not GetEvent("underground")  then -- simulation_objects.is_on_the_actor_level(alife():object(id))
                -- Stop showing active map spot as out of range but don't stop tracking them
                if dist_to_target > MAX_TRACKING_DIST then
                    --pr("Out of detectable range by %sm, removing mapspot", dist_to_target - MAX_TRACKING_DIST)
                    
                    remove_map_spot(id, spot_icon)
                    
                    -- last known location
                    if not entry["lost_contact"] then
                        pr("Lost contact with %s", npc_name)
                        init_last_known_spot(npc, entry, tracking_info)
                        if contains(tracking_npc[id], "last_known_spot", true) then
                            tracking_npc[id]["lost_contact"] = true
                        else
                            pr("last known spot not created")
                        end

                    -- If player exceeds twice the max tracking dist from the last known location, remove the map spot
                    elseif entry["lost_contact"] and entry["last_known_spot"] then
                        --pr("target outside of tracking range but player exceeds distance to last known location")
                        local lk_info = entry["last_known_spot"]
                        local temp_obj_dist = dist_to_pos(db.actor, lk_info["pos"])
                        local remove_dist = MAX_TRACKING_DIST * 2

                        if temp_obj_dist > remove_dist then
                            forget_last_known_spot(id, lk_info, "temp")
                        end
                    end
                    
                elseif dist_to_target <= MAX_TRACKING_DIST then
                    -- Remove last known spot once in trackable distance
                    if entry["lost_contact"] and entry["last_known_spot"] then
                        pr("restablishing contact with %s", npc_name)
                        local lk_info = entry["last_known_spot"]
                        --pr("target back within range, removing last known spot")
                        forget_last_known_spot(id, lk_info, "perm")                     
                    end
                    -- Show tracking info once in range, contact restablished
                    --"target in detectable range, showing map spot"
                    update_map_spot(id, spot_icon, TRACKING_SPOT_TEXT)
                    add_map_spot_hint(id, spot_icon, tracking_info["hint"])
                    tracking_npc[id]["lost_contact"] = false
                end

            else
                -- Remove all possible map spot if not on same level but dont stop tracking
                remove_all_spots(id)
            end
        --
        end
    end
end

-- callbacks

function on_transition()
    local tg = time_global()
    for id, entry in pairs(tracking_npc) do
        if contains(entry, "timeout", true) and tg >= entry["timeout"] then
            pr("stopped tracking %s at %s", id, tg)
            remove_all_spots(id, true)
        end
    end
end

function on_npc_death(victim, killer)
    if is_tracking(victim:id()) then
        remove_aggro_npc(victim, killer)
    end
end

function on_monster_anomaly_death(npc, amount, dir, who, bone_index)
    local npc_health = npc.health
    if npc_health <= 0.005 then
        if IsAnomaly(who) then
            local ammo_type = get_tracker_ammo(npc:id())
            alife():create(ammo_type, npc:position(), npc:level_vertex_id(), npc:game_vertex_id())
        end
    end
end

function is_aggro_npc(npc_id)
    return contains(aggro_npcs, npc_id, true) and aggro_npcs[npc_id] or false
end

function set_aggro_npc(npc)
    if not contains(aggro_npcs, npc:id(), true) then
        aggro_npcs[npc:id()] = true
    end
end

function remove_aggro_npc(npc, enemy, flags)
    if contains(aggro_npcs, npc:id(), true) 
    and not contains(xr_combat_ignore.fighting_with_actor_npcs, npc:id(), true) then
        aggro_npcs[npc:id()] = nil
    end
end

function on_game_start()
    RegisterScriptCallback("npc_on_hit_callback", start_tracking)
    RegisterScriptCallback("monster_on_hit_callback", start_tracking)
    RegisterScriptCallback("monster_on_hit_callback", on_monster_anomaly_death)
    RegisterScriptCallback("npc_on_death_callback", on_npc_death)
    RegisterScriptCallback("monster_on_death_callback", on_npc_death)
    RegisterScriptCallback("actor_on_update", update_tracking)
    RegisterScriptCallback("GUI_on_show", stop_tracking_on_loot)
    --RegisterScriptCallback("on_before_level_changing", on_transition)
    RegisterScriptCallback("monster_on_loot_init", on_monster_loot)
    RegisterScriptCallback("npc_on_fighting_actor", set_aggro_npc)
    RegisterScriptCallback("on_enemy_eval", remove_aggro_npc)
end